<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 07 Reading Notes</title>
    <style>
        .li2 {list-style-type: circle;}
        .li3 {list-style-type: square;}
        span {font-family: 'Courier New', Courier, monospace;}

    </style>
</head>
<body>
    <h1>Reading Notes Week 07</h1>
    <p>
        <h3>Chapter 11: Further Funcgtions</h3>

        <h4>Functions, properties and methods</h4>
            <ul>
                <li>Funcitons are first-class objects</li>
                    <ul>
                        <li style="list-style-type: circle;">This means they can
                            have properties and methods themselves</li>
                        <li class="li2">example: All functions have a length prperty</li>
                        <li class="li2">the <span>call()</span> method can be used to set the value of <span>this</span></li>
                        <ul>
                            <li class="li3">A call that sets a parameter
                                requires and argument. ex: <span>call(arg)</span></li>
                                <li class="li3">You can use a custom object as an argument</li>
                        </ul>
                    </ul> 
                    <li>You can add custom functions and properties</li>
                    <li>Memorization</li>
                    <ul>
                        <li class="li2">lets you <span>cache</span> a value to use later</li>
                    </ul>
            </ul>
        <h4>Immediately Invoked function expressions (IIFE aka 'iffy')</h4>
            <ul>
                <li>An anonymous function that is invoked as soon as it’s defined.</li>
                <li>IIFEs are a useful way of performing a task while keeping any variables wrapped up within the scope of the function. </li>
                <li>Temporary Variables</li>
                <ul>
                    <li class="li2">Placing any code that uses the temporary variable inside an IIFE will ensure it’s only available while the IIFE is invoked, then it will disappear. </li>
                    <li class="li2">This process requires the use of a temporary variable, called <span>temp</span> , which only exists while the IIFE is invoked</li>
                </ul>
                <li>Initialization Code</li>
                <ul>
                    <li class="li2">An IIFE can be used to set up any initialization code that there’ll be no need for again. </li>
                    <li class="li2">Note that much of this can be achieved in ES6 by simply placing the code inside a block. This is because variables have block scope when const or let are used</li>
                </ul>
                <li>Safe Use of Strict Mode</li>
                <ul>
                    <li class="li2">Use strict mode to avoid any sloppy coding practices</li>
                    <li class="li2">One of the problems with simply placing 'use strict' at the beginning of a 
                        file is that it will enforce strict mode on all the JavaScript in the file, and if you’re
                         using other people’s code, there’s no guarantee that they’ve coded in strict mode.</li>
                    <li class="li2">To avoid this, the recommended way to use strict mode is to place all your code inside an IIFE</li>
                </ul>
                <li>Creating Self-contained Code Blocks</li>
                <ul>
                    <li class="li2">An IIFE can be used to enclose a block of code inside its own private scope so it doesn’t interfere
                         with any other part of the program. This way means code can be added or removed separately. </li>
                </ul>
            </ul>
        <h4>Self-defining funcgtions</h4>
            <ul>
                <li>This is done by assigning an anonymous function to a variable that hasthe same name as the function</li>
                <li>If any properties have previously been set on the function, these will be lost when the function redefines itself</li>
                <li>Init-Time Branching</li>
                <ul>
                    <li class="li2">This technique can be used with the feature detection
                        to create functions that rewrite themselves. This enables the functions to work more effectively in the browser, 
                        and avoid checking for features every time they’re invoked.</li>
                </ul>
            </ul>

        <h4>Recursive functions</h4>
            <ul>
                <li>A recursive function is one that invokes itself until a certain condition is met. It’s a useful tool to use when iterative processes are involved.</li>
                
            </ul>

        <h4>Callbacks</h4>
            <ul>
                <li>They’re functions passed to other functions as arguments and then invoked inside the function they are passed to.</li>
                <li>Event-driven Asynchronous Programming</li>
                <li>Callbacks can be used to facilitate event-driven asynchronous programming. 
                    By using callbacks, we ensure that waiting for tasks to complete doesn't
                     hold up the execution of other parts of the program. 
                </li>
                <li> JavaScript is still single-threaded, so only one task can happen at once. 
                    If an event only takes a small amount of time to happen, it will still have 
                    to wait until other parts of the program have executed before the callback is invoked.</li>
                <li<b>Callback Hell</b></li>
                    <ul>
                        <li class="li2">The increase in the use of asynchronous programming in JavaScript 
                            has meant that more and more callbacks are being used. This can result in messy 
                            and confusing 'spaghetti code'. This is when more than one callback is used in 
                            the same function, resulting in a large number of nested blocks that are 
                            difficult to comprehend.</li>
                        
                    </ul>
            </ul>


        <h4>Promises</h4>
        <ul>
            <li>Apromiserepresents the future result of an asynchronous operation. Promises don't do anything 
                that can't already be achieved using callbacks, but they help simplify the process, and avoid 
                the convoluted code that can result from using multiple callbacks.</li>
            <li><b>The Promise Life Cycle</b></li>
            <li>When a promise is created, it calls an asynchronous operation and is then said to bepending. 
                It remains in this state while the operation is taking place. At this stage, the promise is 
                said to beunsettled. Once the operation has completed, the promise is said to have beensettled. 
                A settled promise can result in two different outcomes:</li>
            <ul>
                <li class="li2">Resolved ― the asynchronous operation was completed successfully.</li>
                <li class="li2">Rejected ― the asynchronous operation didn’t work as expected, wasn't 
                    successfully completed or resulted in an error.</li>
                
            </ul>
            <li><b>A Super Promise</b></li>
            <ul>
                <li class="li2">There is a pending phase while you wait on the results of an operation. 
                    Then once the promise is settled, you deal with the results in an appropriate way </li>
                
            </ul>
            <li><b>Creating A Promise</b></li>
            <li>A promise is created using a constructor function. This takes a function called anexecutoras 
                an argument. The executor initializes the promise and starts the asynchronous operation. It 
                also accepts two functions as arguments</li>
            <li><b>Dealing With A Settled Promise</b></li>
            <li>Once a promise has been settled, the then() method can be used to deal with the outcome.</li>
            <li><b>Chaining Multiple Promises</b></li>
            <li> If each function that performs an asynchronous operation returns a promise, we can chain the 
                <span>then()</span> methods together to form a sequential piece of code that’s easy to read. 
                Each promise will only begin once the previous promise has been settled.</li>
            
        </ul>

        <h4>Async functions</h4>
        <ul>
            <li>These functions are preceded by the <span>async</span> keyword and allow you to write asynchronous code as 
                if it was synchronous. This is achieved by using the <span>await</span> operator before an asynchronous 
                function. This will wrap the return value of the function in a promise that can then be 
                assigned to a variable. The next line of code is not executed until the promise is resolved.</li>
        </ul>

        <h4>Functions that return functions</h4>
        <ul>
            <li>We've just seen that functions can accept another function as an argument (a callback), but they can also return a function.</li>

        </ul>

        <h4>Closures</h4>
        <ul>
            <li>Closuresare one of JavaScript’s most powerful features, but they can be difficult to get your head around initially.</li>
        </ul>

        <h4>Functional Programming</h4>
        <ul>
            <li>The ability to pass functions as arguments, return them from other functions, and use anonymous functions and closures, 
                are all fundamental elements of functional programming that JavaScript excels at.</li>
            <li>Pure Functions</li>
                <ol>
                    <li>The return value of a pure function should only depend on the values provided as arguments. It doesn't rely on 
                        values from somewhere else in the program.</li>
                    <li>There are no side-effects. A pure function doesn't change any values or data elsewhere in the program. It only 
                        makes non-destructive data transformations and returns new values, rather than altering any of the underlying data.</li>
                    <li>Referential transparency. Given the same arguments, a pure function will always return the same result.</li>
            </ol>
            <li>In order to follow these rules, any pure function must have:</li>
                <ul>
                    <li class="li2">At least one argument; otherwise the return value must depend on something other than the arguments of the function, breaking the first rule</li>
                    <li class="li2"> return value; otherwise there’s no point in the function (unless it has changed something else in the program – in which case, 
                        it’s broken the 'no side-effects' rule).</li>
                    
                </ul>
        </ul>

        <h4>Currying</h4>
        <ul>
            <li>Curryingis a process that involves the partial application of functions.</li>
            <li>A function is said to be curried when not all arguments have been supplied to the function, 
                so it returns another function that retains the arguments already provided, and expects the 
                remaining arguments that were omitted when the original function was called. A final result 
                is only returned once all the expected arguments have eventually been provided.</li>
            <li>Currying relies on higher-order functions that are able to return partially applied 
                functions. All curried functions are higher-order functions because they return a function, 
                but not all higher-order functions are curried.</li>

        </ul>

    </p>
    <p>
        <h3>Chapter 13: AJAX (Asynchronous JavaScript and XML)</h3>

        <h4>Clients and servers</h4>
        <ul>
            <li>Ajax allows JavaScript to request resources from a server on behalf of the client. 
                The resources requested are usually JSON data or small fragments of text or HTML 
                rather than a whole web page.</li>
                <h5>Same-Origin Policy</h5>
                <p>
                    The same-origin policy in browsers blocks all requests from a domain that is 
                    different from the page making the request. This policy is enforced by all 
                    modern browsers and is to stop any malicious JavaScript being run from an 
                    external source. The problem is that the 
                    APIs of many websites rely on data being transferred across domains.
                </p>
                <p>
                    Cross-origin resource sharing (CORS)is a solution to this problem as it 
                    allows resources to be requested from another website outside the original 
                    domain. The CORS standard works by using HTTP headers to indicate which domains 
                    can receive data. A website can have the necessary information in its headers 
                    to allow external sites access to its API data. Most modern browsers support 
                    this method and respect the restrictions specified in the headers. 
                </p>
        </ul>

        <h5>APIs</h5>
        <ul>
            <p>
                An application programming interface (API) is a collection of methods that allows external 
                access to another program or service. Many websites allow controlled access to their data 
                via public APIs. This means that developers are able to interact with the data and create 
                mashups of third-party services. A weather site, for example, might have an API that provides 
                methods that return information about the weather in a given location, such as temperature, 
                wind speed, and so on. This can then be used to display local weather data on a web page. The 
                information that’s returned by APIs is often serialized as JSON. Since the data is being 
                provided by an external site, CORS will have to be enabled in order to access information 
                from an API. Some services may also require authentication in order to access their APIs.
            </p>
        </ul>


        <h4>The Fetch API</h4>
        <ul>
            <li>
                The standard for requesting and sending data asynchronously across a network.
            </li>
            <li>
                Uses promises to avoid callback hell, and also streamlines a number of concepts
            </li>
            <h5>Basic Usage</h5>
            <p>
                The Fetch API provides a global <span>fetch()</span> method that only has one 
                mandatory argument, 
                which is the URL of the resource you wish to fetch.
            </p>
            <h5>Response Interface</h5>
            <li>Deals with the object that’s returned when the promise is fulfilled.</li>
            <li>Response objects have a number of properties and methods that allow us to process 
                the response effectively.</li>
            <ul>
                <li class="li2">Each response object has an <span>ok</span> property that checks to 
                    see if the response is successful.</li>
                <ul>
                    <li class="li3">This is based on theHTTP status code, which can be accessed using 
                        the <span>status</span> property.</li>
                </ul>
                <li class="li2"><span>200</span> if the response was successful</li>
                <li class="li2"><span>201</span> if a resource was created</li>
                <li class="li2"><span>204</span> when the request is successful but no content is returned</li>
                <li class="li2"><span>true</span> if property is between 200 and 299</li>
                <p>
                    We need to manually check if this happens because the promise will only be rejected 
                    in the case of a network error, rather than something like a '404 page not found error', 
                    which is still considered a successful request in terms of the promise.
                </p>
            </ul>
            <p>
                Some other properties of the Response object are:
                <ul>
                    <li><span>headers</span> A Headers object (see later section) containing any headers
                         associated with the response</li>
                    <li><span>url</span> A string containing the URL of response</li>
                    <li><span>redirected</span> A boolean value that specifies if the response is the 
                        result of a redirect</li>
                    <li><span>type</span> A string value of 'basic', 'cors', 'error' or 'opaque'. A value 
                        of 'basic' is used for a response from the same domain. A value of 'cors' means 
                        the data was received from a valid cross-origin request from a different domain. 
                        A value of 'opaque' is used for a response received from 'no-cors' request from 
                        another domain, which means access to the data will be severely restricted. A value 
                        of 'error' is used when a network error occurs.</li>
                </ul>
            </p>

            <h5>Redirects</h5>
            <p>
                <ul>
                    The <span>redirect()</span> method can be used to redirect to another URL. It creates a new promise 
                    that resolves to the response from the redirected URL
                </ul>
                
            </p>
            <h5>Text Response</h5>
            <p>
                <ul>
                    The <span>text()</span> method takes a stream of text from the response, reads it to completion and then returns 
                    a promise that resolves to a USVSting object that can be treated as a string in JavaScript
                </ul>
            </p>

            <h5>Fill Response</h5>
            <p>
                <ul>
                    The <span>blon()</span> method is used to read a file of raw data, such as an image or a spreadsheet. Once it has read the whole file, 
                    it returns a promise that resolves with a <span>blob</span> object.
                </ul>
            </p>
            <h5>JSON Response</h5>
            <p>
                <ul>
                    The <span>json()</span> method is used to deal with these by transforming a stream of JSON data into a promise that resolves 
                    to a JavaScript object.
                </ul>
            </p>

        </ul>

        <h4>Receiving data with Ajax</h4>

        <h4>Sending Information</h4>
        <ul>
            We can also use Ajax to send information. This can be a variety of formats, but is usually a JSON string.
        </ul>
        <h4>Form data</h4>
        <ul>
            The Fetch API includes the FormData interface, which makes it much easier to submit information in forms using Ajax.
        </ul>

    </p>
</body>
</html>